1、分布式事务理论模型：
  a.X/Open
  b.二阶段/三阶段协议
  c.CAP理论，BASE理论

2、分布式解决方案：
  a.TCC补偿方案
  b.基于可靠性消息的最终一致性方案
  c.最大努力通知型
  
3、分布式角色：
   TC：事务协调器：Seata；
   TM：事务管理器：@GobalTransactional方法
   RM：资源管理器：数据库

4、TCC补偿方案

   描述：
   A、前端接口调用Controller控制器，Controller控制器调用@GobalTransactional方法；
   B、@GobalTransactional方法调用openFeign定义的远程接口Controller方法；
   C、远程接口Controller方法调用自身的Service方法；
   D、自身的Service方法调用自身的Service实现类；
   E、自身的Service实现类调用自身的TCC接口的try()抽象方法；
   F、自身的TCC接口中有@TCCLocal注解，还有try()+commit()+rollback()抽象方法；
   G、try抽象方法中有注解@TwoPhaseBusinessAction(name = "DubboTccActionTwo", commitMethod = "commit", rollbackMethod = "rollback")；
   H、TCC的实现类中那个有try()+commit()+rollback()实现方法；
   I、try()方法是进行资源冻结操作；
   J、commit()方法是进行资源解冻操作；
   K、rollback()方法是进行资源回滚操作；
   
   注意：
   A、TCC事务框架会自动进行失败重试，所以有消息幂等性，可通过唯一标识避免重复补偿
   
 5、基于可靠性消息的最终一致性方案
  
    描述：
    A、前端接口调用Controller控制器，Controller控制器调用@Transactional方法；
    B、@Transactional方法中，先调用异步发送消息队列方法，再执行本地事务，最后返回前端接口执行结果--执行中；
    C、在异步发送消息队列方法中，处理请求，将请求发送到远程服务的消息队列，但消息队列只记录该消息，不让消费者消费；
    E、@Transactional方法执行本地事务后，给消息队列发送本地事务执行结果，根据执行结果，选择让消息队列允许消费者消费该消息/删除该消息；
    D、远程服务的消息通道监听到允许消费请求后，处理请求，并通知消息队列，消息投递成功；
    E、调用方的监听回调方法/定时器查询到消息投递成功后，又可再执行一次新的本地事务方法；
    F、新的本地事务方法中，又可以再次发送消息队列；
  
    注意：
    A、该方案事务由生产者控制，消费者不需要考虑；
    B、如果@Transactional方法执行本地事务后，给消息队列发送本地事务执行结果，发送失败/超时，消息队列服务器就定时主动获取本地事务执行结果；
    C、消息队列服务器定时主动获取本地事务执行结果后，根据执行结果，选择让消费者允许该消息/删除该信息；   
    D、如果消费者没有监听到存在的允许消费请求后，消息队列服务器会重复投递；
    E、如果消费者消费成功，通知消息队列失败，调用者可以调用自身接口获取请求处理结果；
    F、保证的是消息提供者发送的内容，消息消费者一定要收到
    
 6、最大努力通知型
  
    描述：
    A、前端接口调用Controller控制器，Controller控制器调用@Transactional方法；
    B、@Transactional方法中，先执行本地事务，本地事务成功后，再调用异步发送消息队列方法；
    C、在异步发送消息队列方法中，处理请求，将请求发送到远程服务的消息队列；
    D、消费者监听消息队列并消费，消费后将请求结果反馈给调用方；
    E、调用方的监听回调方法的反馈后，执行新的事务，并将新的事务处理结果给消费者；
   
   
   注意：
   A、该方案消费者也可以存在事务；
   B、保证的是消息消费者一定要收到消息提供者发送成功/发送失败的数据，如果收不到，消费者自己去查询提供者没有发送成功的数据；
