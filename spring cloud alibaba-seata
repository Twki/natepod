1、分布式事务理论模型：
  a.X/Open
  b.二阶段/三阶段协议
  c.CAP理论，BASE理论

2、分布式解决方案：
  a.TCC补偿方案
  b.基于可靠性消息的最终一致性方案
  c.最大努力通知型
  
3、分布式角色：
   TC：事务协调器：Seata；
   TM：事务管理器：@GobalTransactional方法
   RM：资源管理器：数据库

4、TCC补偿方案

   描述：
   A、前端接口调用Controller控制器，Controller控制器调用@GobalTransactional方法；
   B、@GobalTransactional方法调用openFeign定义的远程接口Controller方法；
   C、远程接口Controller方法调用自身的Service方法；
   D、自身的Service方法调用自身的Service实现类；
   E、自身的Service实现类调用自身的TCC接口的try()抽象方法；
   F、自身的TCC接口中有@TCCLocal注解，还有try()+commit()+rollback()抽象方法；
   G、try抽象方法中有注解@TwoPhaseBusinessAction(name = "DubboTccActionTwo", commitMethod = "commit", rollbackMethod = "rollback")；
   H、TCC的实现类中那个有try()+commit()+rollback()实现方法；
   I、try()方法是进行资源冻结操作；
   J、commit()方法是进行资源解冻操作；
   K、rollback()方法是进行资源回滚操作；
   
   注意：
   A、TCC事务框架会自动进行失败重试，所以有消息幂等性，可通过唯一标识避免重复补偿
   
 5、基于可靠性消息的最终一致性方案
  
    描述：
    A、前端接口调用Controller控制器，Controller控制器调用@Transactional方法；
    B、@Transactional方法执行本地事务，调用异步发送消息队列方法，返回前端接口执行结果--执行中；
    C、异步发送消息队列方法中，执行请求，将请求发送到远程服务的消息队列信道。
    D、远程服务的消息通道接到请求后，处理请求，并将请求反馈给调用方，可队列可让调用发进行回调监听；
    E、调用方的队列接到反馈后，执行本地事务方法；
    F、本地事务方法中，又可以再次发送消息队列；
  
   
