1、分布式事务理论模型：
  a.X/Open
  b.二阶段/三阶段协议
  c.CAP理论，BASE理论

2、分布式解决方案：
  a.TCC补偿方案
  b.基于可靠性消息的最终一致性方案
  c.最大努力通知型
  
3、分布式角色：
   TC：事务协调器：Seata；
   TM：事务管理器：@GobalTransactional方法
   RM：资源管理器：数据库

4、TCC补偿方案

   描述：
   A、前端接口调用Controller控制器，Controller控制器调用@GobalTransactional方法；
   B、@GobalTransactional方法调用openFeign定义的远程接口Controller方法；
   C、远程接口Controller方法调用自身的Service方法；
   D、自身的Service方法调用自身的Service实现类；
   E、自身的Service实现类调用自身的TCC接口的try()抽象方法；
   F、自身的TCC接口中有@TCCLocal注解，还有try()+commit()+rollback()抽象方法；
   G、try抽象方法中有注解@TwoPhaseBusinessAction(name = "DubboTccActionTwo", commitMethod = "commit", rollbackMethod = "rollback")；
   H、TCC的实现类中那个有try()+commit()+rollback()实现方法；
   I、try()方法是进行资源冻结操作；
   J、commit()方法是进行资源解冻操作；
   K、rollback()方法是进行资源回滚操作；
   
   注意：
   A、TCC事务框架会自动进行失败重试，所以有消息幂等性，可通过唯一标识避免重复补偿
   
 5、基于可靠性消息的最终一致性方案
  
    描述：
    A、前端接口调用Controller控制器，Controller控制器调用@Transactional方法；
    B、@Transactional方法中，调用异步发送消息队列方法，执行本地事务，返回前端接口执行结果--执行中；
    C、异步发送消息队列方法中，执行请求，将请求发送到远程服务的消息队列，但消息队列只记录该消息，不让消费者消费；
    E、@Transactional方法执行本地事务后，给消息队列发送本地事务执行结果，根据执行结果，选择让消息队列允许消费者消费该消息/删除该消息；
    D、远程服务的消息通道监听到允许消费请求后，处理请求，并通知消息队列，消息投递成功；
    E、调用方的监听回调方法/定时器查询到消息投递成功后，又可再执行一次新的本地事务方法；
    F、新的本地事务方法中，又可以再次发送消息队列；
  
    注意：
    A、该方案事务由生产者控制，消费者不需要考虑；
    B、如果@Transactional方法执行本地事务后，给消息队列发送本地事务执行结果，发送失败，消息队列服务器就定时主动获取本地事务执行结果；
    C、消息队列服务器定时主动获取本地事务执行结果后，根据执行结果，选择让消费者允许该消息/删除该信息；   
    D、回到上文Setp-D；
